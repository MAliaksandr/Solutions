%YAML 1.1
--- 
StructureVersion: "1.0"
Properties: 
  RUID: 149970855_837256873
  Name: "GS.Клиентские решения.WESTA.Процедуры"
  Caption: "GS.Клиентские решения.WESTA.Процедуры"
  Version: "1.0.0.11"
  Optional: False
  Internal: True
  MD5: EBB40B3B6D0FAE36D9ABB3267843E2B6
Objects: 
  - 
    Properties: 
      Class: "TgdcException"
      RUID: 147027478_574644905
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      EXCEPTIONMESSAGE: "Detected infinite loop"
      EXCEPTIONNAME: "USR$GS_E_INFINITE_LOOP"
      LMESSAGE: "Обнаружен бесконечный цикл"
      SYSTEM_FLAG: 0
      EDITIONDATE: 2016-04-13T15:02:30+03:00
      DESCRIPTION: ~
  - 
    Properties: 
      Class: "TgdcStoredProc"
      RUID: 147027490_574644905
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      PROCEDURENAME: "USR$ORDER_BY_KINDTYPE"
      EDITIONDATE: 2018-04-06T13:26:12+03:00
      PROCEDURESOURCE: | 
        CREATE OR ALTER PROCEDURE USR$ORDER_BY_KINDTYPE (
            ORDERKEY INTEGER)
        RETURNS ( 
            ORDERLINEKEY INTEGER,
            SUMPOS DOUBLE PRECISION,
            QTYPOS DOUBLE PRECISION,
            KINDTYPEKEY INTEGER,
            OPERATIONTYPE SMALLINT,
            CREDCARDIN SMALLINT,
            ISEXTRA SMALLINT)
         AS
           DECLARE VARIABLE Order_SysNum TYPE OF COLUMN USR$MN_ORDER.USR$SYSNUM;
          DECLARE VARIABLE Line_Cost TYPE OF COLUMN USR$MN_ORDERLINE.USR$COSTNCUWITHDISCOUNT;
          DECLARE VARIABLE Line_Summ TYPE OF COLUMN USR$MN_ORDERLINE.USR$SUMNCUWITHDISCOUNT;
          DECLARE VARIABLE Line_Quantity NUMERIC(15, 9);
          DECLARE VARIABLE Line_ExtraQuantity TYPE OF COLUMN USR$MN_ORDERLINE.USR$QUANT_SPECFOOD;
          DECLARE VARIABLE SumNal NUMERIC(15, 4);
          DECLARE VARIABLE SumCard NUMERIC(15, 4);
          DECLARE VARIABLE SumCredit NUMERIC(15, 4);
          DECLARE VARIABLE SumBN NUMERIC(15, 4);
          DECLARE VARIABLE SumExtra NUMERIC(15, 4);
        
          DECLARE VARIABLE KindPayment_Cash INTEGER;
          DECLARE VARIABLE KindPayment_Card INTEGER;
          DECLARE VARIABLE KindPayment_BN INTEGER;
          DECLARE VARIABLE KindPayment_Credit INTEGER;
          DECLARE VARIABLE KindPayment_ExtraFood INTEGER;
        
          DECLARE VARIABLE WHILE_COUNT INTEGER;
        BEGIN
        
        
          EXECUTE PROCEDURE GD_P_GETID(147141777, 349813242) RETURNING_VALUES :KindPayment_Cash;
          EXECUTE PROCEDURE GD_P_GETID(147141780, 349813242) RETURNING_VALUES :KindPayment_Card;
          EXECUTE PROCEDURE GD_P_GETID(147141778, 349813242) RETURNING_VALUES :KindPayment_BN;
          EXECUTE PROCEDURE GD_P_GETID(149056596, 1324113560) RETURNING_VALUES :KindPayment_Credit;
          EXECUTE PROCEDURE GD_P_GETID(147048762, 355551483) RETURNING_VALUES :KindPayment_ExtraFood;
        
          SELECT
            SUM(IIF(p.USR$PAYKINDKEY = :KindPayment_Cash, p.USR$SUMNCU, 0)) AS SumNal,
            SUM(IIF(p.USR$PAYKINDKEY = :KindPayment_Card, p.USR$SUMNCU, 0)) AS SumCard,
            SUM(IIF(p.USR$PAYKINDKEY = :KindPayment_BN, p.USR$SUMNCU, 0)) AS SumBN,
            SUM(IIF(p.USR$PAYKINDKEY = :KindPayment_Credit, p.USR$SUMNCU, 0)) AS SumCredit,
            SUM(IIF(p.USR$PAYKINDKEY = :KindPayment_ExtraFood, p.USR$SUMNCU, 0)) AS SumExtra
          FROM
            USR$MN_PAYMENT p
          JOIN USR$MN_KINDTYPE KT on KT.ID = p.USR$PAYKINDKEY
          WHERE
            p.USR$ORDERKEY = :OrderKey
          INTO :SumNal, :SumCard, :SumBN, :SumCredit, :SumExtra;
        
          IF (SumNal IS NULL AND SumCard IS NULL AND SumBN IS NULL AND SumExtra IS NULL) THEN EXIT;
          SumNal = COALESCE(SumNal, 0);
          SumCard = COALESCE(SumCard, 0);
          SumCredit = COALESCE(SumCredit, 0);
          SumBN = COALESCE(SumBN, 0);
          SumExtra = COALESCE(SumExtra, 0);
        
          FOR
          SELECT
            o.DOCUMENTKEY,
            ol.DOCUMENTKEY,
            o.USR$SYSNUM as sysNum,
            ol.USR$COSTNCU,
            IIF(COALESCE(ol.USR$QUANT_SPECFOOD, 0) > 0, (ol.USR$QUANT_SPECFOOD * ol.USR$COSTNCUWITHDISCOUNT), ol.USR$SUMNCUWITHDISCOUNT) AS Summ,
            IIF(COALESCE(ol.USR$QUANT_SPECFOOD, 0) > 0, ol.USR$QUANT_SPECFOOD, ol.USR$QUANTITY)AS QTY,
            IIF(COALESCE(ol.USR$QUANT_SPECFOOD, 0) > 0, 1, 0) SPECQTY
          FROM USR$MN_ORDERLINE ol
          JOIN USR$MN_ORDER o ON ol.MASTERKEY = o.DOCUMENTKEY
          WHERE ol.MASTERKEY = :OrderKey
          UNION ALL
          SELECT
            o.DOCUMENTKEY,
            ol.DOCUMENTKEY,
            o.USR$SYSNUM as sysNum,
            ol.USR$COSTNCU,
            (ol.USR$QUANTITY - COALESCE(ol.USR$QUANT_SPECFOOD, 0)) * ol.USR$COSTNCUWITHDISCOUNT AS Summ,
            ol.USR$QUANTITY - COALESCE(ol.USR$QUANT_SPECFOOD, 0) AS QTY,
            0 SPECQTY
          FROM USR$MN_ORDERLINE ol
          JOIN USR$MN_ORDER o ON ol.MASTERKEY = o.DOCUMENTKEY
          WHERE
            ol.MASTERKEY = :OrderKey
            AND COALESCE(ol.USR$QUANT_SPECFOOD, 0) > 0
            AND ol.USR$QUANTITY - COALESCE(ol.USR$QUANT_SPECFOOD, 0) > 0
          INTO :OrderKey, :OrderLineKey, :Order_SysNum, :Line_Cost, :Line_Summ, :Line_Quantity, :Line_ExtraQuantity
        
          DO
          BEGIN
            WHILE_COUNT = 0;
            QtyPos = 0;
            SumPos = 0;
        
            WHILE (Line_Summ > 0) DO WHILE (1=1) DO
            BEGIN
              IsExtra = 0;
        
              /*Вычитаем сумму из оплаты по позиции*/
              IF (QtyPos = 0) THEN
                QtyPos = Line_Quantity;
              ELSE
                QtyPos = Line_Quantity - QtyPos;
        
        
              IF (Line_ExtraQuantity > 0) THEN
              BEGIN
                IsExtra = 1;
        
                QtyPos = QtyPos - Line_ExtraQuantity;
                IF (QtyPos <= 0) THEN QtyPos = 1;
                Line_ExtraQuantity = 0;
        
                SumPos = Line_Summ;
                Line_Summ = Line_Summ - SumExtra;
                SumExtra = 0;
                IF (CAST(QtyPos AS INTEGER) != QtyPos) THEN
                  QtyPos = Round(SumPos/Line_Cost, 9);
        
                OperationType = 5;
                CredCardIn = 2;
        
                KindTypeKey = KindPayment_ExtraFood;
        
                SUSPEND;
                LEAVE;
              END
        
              IF (SumBN > 0) THEN
              BEGIN
                IF (SumBN >= Line_Summ) THEN
                BEGIN
                  /*Если сумма оплаты (б\н) больше суммы по позиции
                  то вычитаем из суммы оплаты сумму позиции, и обнуляем временную сумму*/
        
                  SumPos = Line_Summ;
                  SumBN = SumBN - Line_Summ;
                  Line_Summ = 0;
                  IF (CAST(QtyPos AS INTEGER) != QtyPos) THEN
                    QtyPos = Round(SumPos/Line_Cost, 9);
                END
                ELSE
                BEGIN
                  /*Если сумма оплаты (б\н) меньше суммы по позиции*/
        
                  SumPos = SumBN;
                  QtyPos = Round(SumPos/Line_Cost, 9);/*Round(CAST(Line_Quantity AS DOUBLE PRECISION) * SumBN/Line_Summ, 9);*/
                  Line_Summ = Line_Summ - SumBN;
                  SumBN = 0;
                END
                OperationTYpe = 5;
                CredCardIn = 1;
        
                KindTypeKey = KindPayment_BN;
        
                SUSPEND;
                LEAVE;
              END
        
              IF (SumCredit > 0) THEN
              BEGIN
                IF (SumCredit >= Line_Summ) THEN
                BEGIN
                  /*Если сумма оплаты (в кредит) больше суммы по позиции
                  то вычитаем из суммы оплаты сумму позиции, и обнуляем временную сумму*/
        
                  SumPos = Line_Summ;
                  SumCredit = SumCredit - Line_Summ;
                  Line_Summ = 0;
                  IF (CAST(QtyPos AS INTEGER) != QtyPos) THEN
                    QtyPos = Round(SumPos/Line_Cost, 9);
                END
                ELSE
                BEGIN
                  /*Если сумма оплаты (в кредит) меньше суммы по позиции*/
        
                  SumPos = SumCredit;
                  QtyPos = Round(SumPos/Line_Cost, 9);/*Round(CAST(Line_Quantity AS DOUBLE PRECISION) * SumCredit/Line_Summ, 9);*/
                  Line_Summ = Line_Summ - SumCredit;
                  SumCredit = 0;
                END
                OperationTYpe = 5;
                CredCardIn = 1;
        
                KindTypeKey = KindPayment_Credit;
        
                SUSPEND;
                LEAVE;
              END
        
              IF (SumCard > 0) THEN
              BEGIN
                IF (SumCard >= Line_Summ) THEN
                BEGIN
                  /*Если сумма оплаты (карта) больше суммы по позиции
                  то вычитаем из суммы оплаты сумму позиции, и обнуляем временную сумму*/
        
                  SumPos = Line_Summ;
                  SumCard = SumCard - Line_Summ;
                  Line_Summ = 0;
                  IF (CAST(QtyPos AS INTEGER) != QtyPos) THEN
                    QtyPos = Round(SumPos/Line_Cost, 9);
                END
                ELSE
                BEGIN
                  /*Если сумма оплаты (карта) меньше суммы по позиции*/
        
                  SumPos = SumCard;
                  QtyPos = Round(SumPos/Line_Cost, 9);/*Round(CAST(Line_Quantity AS DOUBLE PRECISION) * SumCard/Line_Summ, 9);*/
                  Line_Summ = Line_Summ - SumCard;
                  SumCard = 0;
                END
                OperationTYpe = 5;
                CredCardIn = 3;
        
                KindTypeKey = KindPayment_Card;
        
                SUSPEND;
                LEAVE;
              END
        
              IF (SumNal > 0) THEN
              BEGIN
                IF (SumNal >= Line_Summ) THEN
                BEGIN
                  /*Если сумма оплаты (наличные) больше суммы по позиции
                  то вычитаем из суммы оплаты сумму позиции, и обнуляем временную сумму*/
        
                  SumPos = Line_Summ;
                  SumNal = SumNal - Line_Summ;
                  Line_Summ = 0;
                  IF (CAST(QtyPos AS INTEGER) != QtyPos) THEN
                    QtyPos = Round(SumPos/Line_Cost, 9);
                END
                ELSE
                BEGIN
                  /*Если сумма оплаты (наличные) меньше суммы по позиции*/
        
                  SumPos = SumNal;
                  QtyPos = Round(SumPos/Line_Cost, 9);/*Round(CAST(Line_Quantity AS DOUBLE PRECISION) * SumNal/Line_Summ, 9);*/
                  Line_Summ = Line_Summ - SumNal;
                  SumNal = 0;
                END
                OperationType = 1;
                CredCardIn = 0;
        
                KindTypeKey = KindPayment_Cash;
        
                SUSPEND;
                LEAVE;
              END
        
              WHILE_COUNT = WHILE_COUNT + 1;
        
              /*для проверки на бесконечный цикл*/
              IF (WHILE_COUNT > 100) THEN
                EXCEPTION USR$GS_E_INFINITE_LOOP;
        
              LEAVE;
            END
          END
        END
      RDB$DESCRIPTION: | 
        Заказ по типам оплаты
  - 
    Properties: 
      Class: "TgdcStoredProc"
      RUID: 149969336_837256873
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      PROCEDURENAME: "USR$WESTA_SALES"
      EDITIONDATE: 2018-04-06T13:26:12+03:00
      PROCEDURESOURCE: | 
        CREATE OR ALTER PROCEDURE USR$WESTA_SALES 
        RETURNS ( 
            ORDER_ID INTEGER,
            LOGICDATE DATE,
            FRONT_ID INTEGER,
            FRONT_NAME VARCHAR(60),
            FROMDOCTOR_ID INTEGER,
            FROMDOCTOR_NAME VARCHAR(60),
            TODOCTOR_ID INTEGER,
            TODOCTOR_NAME VARCHAR(60),
            CUSTOMER_ID INTEGER,
            CUSTOMER_NAME VARCHAR(60),
            ISRESIDENT SMALLINT,
            GROUP_ID INTEGER,
            GROUP_NAME VARCHAR(60),
            GOOD_ID INTEGER,
            GOOD_NAME VARCHAR(180),
            VALUE_ID INTEGER,
            VALUE_NAME VARCHAR(180),
            COSTNCU NUMERIC(15, 4),
            QUANTITY NUMERIC(15, 4),
            SUMNCU NUMERIC(15, 4),
            SUMDISCOUNT NUMERIC(15, 4))
         AS
        BEGIN
          FOR
          SELECT
            o.DOCUMENTKEY,
            o.USR$LOGICDATE AS LOGICDATE,
            front.ID AS FRONT_ID,
            front.USR$NAME AS FRONT_NAME,
            fdoc.ID AS FROMDOCTOR_ID,
            fdoc.NAME AS FROMDOCTOR_NAME,
            tdoc.ID AS TODOCTOR_ID,
            tdoc.NAME AS TODOCTOR_NAME,
            con.ID AS CUSTOMER_ID,
            con.NAME AS CUSTOMER_NAME,
            IIF(p.USR$NATIONALITYKEY = 1800010, 1, 0) AS IsResident,
            gr.ID AS GROUP_ID,
            gr.NAME AS GROUP_NAME,
            good.ID AS GOOD_ID,
            good.NAME AS GOOD_NAME,
            val.ID AS VALUE_ID,
            val.NAME AS VALUE_NAME,
            ol.USR$COSTNCUWITHDISCOUNT AS COSTNCU,
            IIF(COALESCE(o.USR$RETURNED, 0) = 1, -ol.USR$QUANTITY, ol.USR$QUANTITY) AS QUANTITY,
            IIF(COALESCE(o.USR$RETURNED, 0) = 1, -ol.USR$SUMNCUWITHDISCOUNT, ol.USR$SUMNCUWITHDISCOUNT) AS SUMNCU,
            IIF(COALESCE(o.USR$RETURNED, 0) = 1, -ol.USR$SUMDISCOUNT, ol.USR$SUMDISCOUNT) AS SUMDISCOUNT
          FROM USR$MN_ORDER o
            LEFT JOIN GD_CONTACT con ON con.ID = o.USR$CUSTOMER
            LEFT JOIN GD_PEOPLE p ON p.CONTACTKEY  =  con.ID
            LEFT JOIN GD_PLACE gp ON gp.ID = p.HPLACEKEY
            LEFT JOIN GD_PLACE gp_main ON gp_main.LB <= gp.LB AND gp_main.RB >= gp.RB AND gp_main.PARENT IS NULL
            JOIN USR$MN_ORDERLINE ol ON ol.MASTERKEY = o.DOCUMENTKEY
            LEFT JOIN GD_CONTACT fdoc ON fdoc.ID = ol.USR$FROMDOCTORKEY
            LEFT JOIN GD_CONTACT tdoc ON tdoc.ID = ol.USR$TODOCTORKEY
            JOIN GD_GOOD good ON good.ID = ol.USR$GOODKEY
            JOIN GD_VALUE val ON val.ID = good.VALUEKEY
            JOIN GD_GOODGROUP gr ON gr.ID = good.GROUPKEY
            JOIN USR$MN_FRONTLIST front ON front.ID = o.USR$MN_FRONTKEY
          /*WHERE COALESCE(o.USR$RETURNED, 0) = 0*/
          INTO :ORDER_ID, :LOGICDATE, :FRONT_ID, :FRONT_NAME, :FROMDOCTOR_ID, :FROMDOCTOR_NAME, :TODOCTOR_ID, :TODOCTOR_NAME, :CUSTOMER_ID, :CUSTOMER_NAME, :IsResident, :GROUP_ID, :GROUP_NAME, :GOOD_ID, :GOOD_NAME, :VALUE_ID, :VALUE_NAME, :COSTNCU, :QUANTITY, :SUMNCU, :SUMDISCOUNT
          DO
            SUSPEND;
        END
      RDB$DESCRIPTION: | 
        Список продаж со специфичной информацией весты
  - 
    Properties: 
      Class: "TgdcStoredProc"
      RUID: 154384163_858116376
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      PROCEDURENAME: "USR$WESTA_SERTIFICATE_MED"
      EDITIONDATE: 2018-04-06T13:26:12+03:00
      PROCEDURESOURCE: | 
        CREATE OR ALTER PROCEDURE USR$WESTA_SERTIFICATE_MED 
        RETURNS ( 
            DOC_ID INTEGER,
            LOGICDATE DATE,
            NUMBER VARCHAR(20),
            FRONT_ID INTEGER,
            FRONT_NAME VARCHAR(60),
            INSURANCE_ID INTEGER,
            INSURANCE_NAME VARCHAR(60),
            CUSTOMER_ID INTEGER,
            CUSTOMER_NAME VARCHAR(60),
            ISRESIDENT SMALLINT,
            FROMDOCTOR_ID INTEGER,
            FROMDOCTOR_NAME VARCHAR(60),
            TODOCTOR_ID INTEGER,
            TODOCTOR_NAME VARCHAR(60),
            GROUP_ID INTEGER,
            GROUP_NAME VARCHAR(60),
            GOOD_ID INTEGER,
            GOOD_NAME VARCHAR(180),
            VALUE_ID INTEGER,
            VALUE_NAME VARCHAR(180),
            COSTNCU NUMERIC(15, 4),
            QUANTITY NUMERIC(15, 4),
            SUMNCU NUMERIC(15, 4))
         AS
        BEGIN
          FOR
          SELECT
            doc.ID,
            doc.DOCUMENTDATE AS LOGICDATE,
            doc.NUMBER,
            front.ID AS FRONT_ID,
            front.USR$NAME AS FRONT_NAME,
            ins.ID AS INSURANCE_ID,
            ins.NAME AS INSURANCE_NAME,
            con.ID AS CUSTOMER_ID,
            con.NAME AS CUSTOMER_NAME,
            IIF(p.USR$NATIONALITYKEY = 1800010, 1, 0) AS IsResident,
            fdoc.ID AS FROMDOCTOR_ID,
            fdoc.NAME AS FROMDOCTOR_NAME,
            tdoc.ID AS TODOCTOR_ID,
            tdoc.NAME AS TODOCTOR_NAME,
            gr.ID AS GROUP_ID,
            gr.NAME AS GROUP_NAME,
            good.ID AS GOOD_ID,
            good.NAME AS GOOD_NAME,
            val.ID AS VALUE_ID,
            val.NAME AS VALUE_NAME,
            sml.USR$PRICE,
            sml.USR$QUANTITY,
            sml.USR$TOTALSUM
          FROM GD_DOCUMENT doc
            JOIN USR$SERTIFICATE_MEDSERVICE sm ON sm.DOCUMENTKEY = doc.ID
            JOIN USR$SERTIFICATE_MEDSERVICELINE sml ON sml.MASTERKEY = sm.DOCUMENTKEY
            JOIN GD_CONTACT ins ON ins.ID = sm.USR$INSURANCECOMPANY
            LEFT JOIN GD_CONTACT fdoc ON fdoc.ID = sml.USR$FROMDOCTORKEY
            LEFT JOIN GD_CONTACT tdoc ON tdoc.ID = sml.USR$TODOCTORKEY
            JOIN GD_GOOD good ON good.ID = sml.USR$SERVICEKEY
            JOIN GD_VALUE val ON val.ID = good.VALUEKEY
            JOIN GD_GOODGROUP gr ON gr.ID = good.GROUPKEY
            JOIN USR$MN_FRONLINK fl ON fl.USR$DEPKEY = sm.USR$DEPTKEY
            JOIN USR$MN_FRONTLIST front ON front.ID = fl.USR$FRONTKEY
            LEFT JOIN GD_CONTACT con ON con.ID = sm.USR$CLIENT
            LEFT JOIN GD_PEOPLE p ON p.CONTACTKEY  =  con.ID
            LEFT JOIN GD_PLACE gp ON gp.ID = p.HPLACEKEY
            LEFT JOIN GD_PLACE gp_main ON gp_main.LB <= gp.LB AND gp_main.RB >= gp.RB AND gp_main.PARENT IS NULL
          INTO :DOC_ID, :LOGICDATE, :NUMBER, :FRONT_ID, :FRONT_NAME, :INSURANCE_ID, :INSURANCE_NAME, :CUSTOMER_ID, :CUSTOMER_NAME, :IsResident, :FROMDOCTOR_ID, :FROMDOCTOR_NAME, :TODOCTOR_ID, :TODOCTOR_NAME, :GROUP_ID, :GROUP_NAME, :GOOD_ID, :GOOD_NAME, :VALUE_ID, :VALUE_NAME, :COSTNCU, :QUANTITY, :SUMNCU
          DO
            SUSPEND;
        END
      RDB$DESCRIPTION: | 
        Реализация услуг по страховкам